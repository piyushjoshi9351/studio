/**
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model. All data is considered private and
 * is only accessible by the user who created it. There is no concept of public data or
 * shared access between users in this model. The default security posture is to deny all
 * access unless explicitly permitted.
 *
 * Data Structure:
 * All application data is organized hierarchically under a user's root document. The
 * structure `/users/{userId}/{subcollection}/{documentId}` is used for all data entities.
 * This path-based ownership is the cornerstone of the security model, allowing for simple,
 * performant, and highly secure rules.
 *
 * Key Security Decisions:
 * - Strict Path-Based Ownership: A user's access is determined entirely by matching their
 *   authentication UID (`request.auth.uid`) with the `{userId}` wildcard in the document path.
 * - No Cross-User Access: Users are completely siloed and cannot read, write, or even list
 *   data belonging to another user.
 * - No Public Listing: Listing all users is disallowed. Listing documents is only permitted on a
 *   user's own subcollections.
 * - Collection Group Queries: To allow users to view all their summaries on the 'History' page,
 *   a collection group query on the `summaries` collection is permitted, but strictly filtered
 *   to the requesting user's `userId`.
 *
 * Denormalization for Authorization:
 * This model is an excellent example of using the data structure for authorization. By nesting
 * all user-content within a `/users/{userId}` path, we avoid the need for slow and costly `get()`
 * calls to other documents to verify ownership. The authorization decision is made solely based
 * on the request's path and the user's authenticated UID.
 *
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Verifies that a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Verifies that the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing user ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * A robust check for update/delete operations, ensuring the user is the owner
     * AND the document actually exists before the operation.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * On CREATE: Validates that the new User document contains an `id` field
     * that matches the document's path ID.
     */
    function hasValidUserDataOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * On UPDATE: Enforces that the `id` field of a User document is immutable.
     */
    function hasValidUserDataOnUpdate() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * On CREATE: Validates that the new Document contains a `userId` field
     * that matches the user's path ID.
     */
    function hasValidDocumentDataOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * On UPDATE: Enforces that the `userId` field of a Document is immutable.
     */
    function hasValidDocumentDataOnUpdate() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * On CREATE: Validates that the new Summary contains a `documentId` and `userId` field
     * that matches the parent path IDs.
     */
    function hasValidSummaryDataOnCreate(userId, documentId) {
      return request.resource.data.userId == userId && request.resource.data.documentId == documentId;
    }

    /**
     * On UPDATE: Enforces that the `documentId` and `userId` fields of a Summary are immutable.
     */
    function hasValidSummaryDataOnUpdate() {
      return request.resource.data.documentId == resource.data.documentId && request.resource.data.userId == resource.data.userId;
    }
    
    /**
     * On CREATE: Validates that the new ChatMessage contains `userId` and `documentId`
     * fields that match the parent path IDs.
     */
    function hasValidChatMessageDataOnCreate(userId, documentId) {
      return request.resource.data.userId == userId && request.resource.data.documentId == documentId;
    }
    
    /**
     * On UPDATE: Enforces that the `userId` and `documentId` fields of a ChatMessage are immutable.
     */
    function hasValidChatMessageDataOnUpdate() {
      return request.resource.data.userId == resource.data.userId && request.resource.data.documentId == resource.data.documentId;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description A user can create their own profile, and then only they can read, update, or delete it.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users in the database.
      allow create: if isOwner(userId) && hasValidUserDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && hasValidUserDataOnUpdate();
      allow delete: if isExistingOwner(userId);

      /**
       * @description A user can manage all documents within their own user space.
       */
      match /documents/{documentId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidDocumentDataOnCreate(userId);
        allow update: if isExistingOwner(userId) && hasValidDocumentDataOnUpdate();
        allow delete: if isExistingOwner(userId);

        /**
         * @description A user can manage summaries related to their own documents.
         *              Read access is handled by the collection group rule below.
         */
        match /summaries/{summaryId} {
          allow get: if false; // Deny direct reads, force use of collection group query with security.
          allow list: if false; // Deny direct lists, force use of collection group query with security.
          allow create: if isOwner(userId) && hasValidSummaryDataOnCreate(userId, documentId);
          allow update: if isExistingOwner(userId) && hasValidSummaryDataOnUpdate();
          allow delete: if isExistingOwner(userId);
        }
        
        /**
         * @description A user can manage chat messages related to their own documents.
         */
        match /chat_messages/{chatMessageId} {
            allow get, list: if isOwner(userId);
            allow create: if isOwner(userId) && hasValidChatMessageDataOnCreate(userId, documentId);
            allow update: if isExistingOwner(userId) && hasValidChatMessageDataOnUpdate();
            allow delete: if isExistingOwner(userId);
        }
      }
    }
    
    // ----------------------------------------------------------------------
    // Collection Group Rules
    // ----------------------------------------------------------------------

    /**
     * @description Allows a user to list their own summaries across all documents for the 'History' page.
     *              This single rule governs all read access to summaries.
     * @principle   Enables a required feature while maintaining strict user data isolation.
     * @robustness  The client query MUST contain `where("userId", "==", request.auth.uid)` for this to work.
     */
    match /{path=**}/summaries/{summaryId} {
        allow read: if isSignedIn() && request.auth.uid == resource.data.userId;
    }
  }
}
