/**
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model. All data is considered private and
 * is only accessible by the user who created it. There is no concept of public data or
 * shared access between users in this model. The default security posture is to deny all
 * access unless explicitly permitted.
 *
 * Data Structure:
 * All application data is organized hierarchically under a user's root document. The
 * structure `/users/{userId}/{subcollection}/{documentId}` is used for all data entities.
 * This path-based ownership is the cornerstone of the security model, allowing for simple,
 * performant, and highly secure rules.
 *
 * Key Security Decisions:
 * - Strict Path-Based Ownership: A user's access is determined entirely by matching their
 *   authentication UID (`request.auth.uid`) with the `{userId}` wildcard in the document path.
 * - No Cross-User Access: Users are completely siloed and cannot read, write, or even list
 *   data belonging to another user.
 * - No Public Listing: Listing all users is disallowed. Listing documents is only permitted on a
 *   user's own subcollections.
 * - Collection Group Queries: To allow users to view all their summaries on the 'History' page,
 *   a collection group query on the `summaries` collection is permitted, but strictly filtered
 *   to the requesting user's `userId`.
 *
 * Denormalization for Authorization:
 * This model is an excellent example of using the data structure for authorization. By nesting
 * all user-content within a `/users/{userId}` path, we avoid the need for slow and costly `get()`
 * calls to other documents to verify ownership. The authorization decision is made solely based
 * on the request's path and the user's authenticated UID.
 *
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Verifies that a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Verifies that the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing user ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * A robust check for update/delete operations, ensuring the user is the owner
     * AND the document actually exists before the operation.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * On CREATE: Validates that the new User document contains an `id` field
     * that matches the document's path ID.
     */
    function hasValidUserDataOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * On UPDATE: Enforces that the `id` field of a User document is immutable.
     */
    function hasValidUserDataOnUpdate() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * On CREATE: Validates that the new Document contains a `userId` field
     * that matches the user's path ID.
     */
    function hasValidDocumentDataOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * On UPDATE: Enforces that the `userId` field of a Document is immutable.
     */
    function hasValidDocumentDataOnUpdate() {
      return request.resource.data.userId == resource.data.userId;
    }
    
    /**
     * On CREATE: Validates that the new ChatMessage contains `userId` and `documentId`
     * fields that match the parent path IDs.
     */
    function hasValidChatMessageDataOnCreate(userId, documentId) {
      return request.resource.data.userId == userId && request.resource.data.documentId == documentId;
    }
    
    /**
     * On UPDATE: Enforces that the `userId` and `documentId` fields of a ChatMessage are immutable.
     */
    function hasValidChatMessageDataOnUpdate() {
      return request.resource.data.userId == resource.data.userId && request.resource.data.documentId == resource.data.documentId;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description A user can create their own profile, and then only they can read, update, or delete it.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users in the database.
      allow create: if isOwner(userId) && hasValidUserDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && hasValidUserDataOnUpdate();
      allow delete: if isExistingOwner(userId);

      /**
       * @description A user can manage all documents within their own user space.
       */
      match /documents/{documentId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidDocumentDataOnCreate(userId);
        allow update: if isExistingOwner(userId) && hasValidDocumentDataOnUpdate();
        allow delete: if isExistingOwner(userId);
        
        /**
         * @description A user can manage chat messages related to their own documents.
         */
        match /chat_messages/{chatMessageId} {
            allow get, list: if isOwner(userId);
            allow create: if isOwner(userId) && hasValidChatMessageDataOnCreate(userId, documentId);
            allow update: if isExistingOwner(userId) && hasValidChatMessageDataOnUpdate();
            allow delete: if isExistingOwner(userId);
        }
      }
    }
    
    // ----------------------------------------------------------------------
    // Collection Group Rules
    // ----------------------------------------------------------------------

    /**
     * @description This single rule governs all access to the `summaries` collection group.
     *              It ensures users can only access their own summaries.
     */
    match /{path=**}/summaries/{summaryId} {
      /**
       * @description Allows a user to read their own summaries. This enables the collection group query
       *              for the 'History' page. The client query MUST filter by `userId`.
       * @robustness  The `&& 'userId' in resource.data` check ensures the query doesn't fail if old
       *              documents are missing the `userId` field.
       */
      allow read: if isSignedIn() 
                    && 'userId' in resource.data 
                    && request.auth.uid == resource.data.userId;

      /**
       * @description Allows a user to create a summary if the new document's `userId` matches
       *              their own authenticated UID.
       */
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      
      /**
       * @description Allows a user to update or delete a summary if the existing document's `userId`
       *              matches their own authenticated UID. Also ensures the userId cannot be changed.
       */
      allow update: if isSignedIn() 
                      && resource.data.userId == request.auth.uid
                      && request.resource.data.userId == resource.data.userId;

      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }
  }
}
